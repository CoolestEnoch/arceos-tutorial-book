# 依靠axhal组件实现从系统引导到输出

ArceOS是一个组件化的操作系统 ，接下来三部分，我们将会对ArceOS的代码进行一点点修改，以体现组件间的密切联系和展示ArceOS启动的流程。

这一节我们将会以helloworld应用程序为例了解ArceOS运行的流程。

我们都知道，我们的输出都是通过硬件完成的，正如你现在正在看的这份文档，它能显示在屏幕上都得益于我们的操作系统。但是我们的目标不正是写一个操作系统吗，很遗憾我们只能自己添加上与硬件相关的层的封装了，axhal应运而生。

```mermaid
graph TD
axhal
```

axhal组件提供了一层针对不同硬件平台的硬件封装，通过对axhal组件的调用，相当于我们直接可以对硬件进行操控，例如modules/axhal/src/platform/qemu_virt_riscv/console.rs里面提供了对字符输出的封装，我们可以直接调用这个函数进行字符的输出，接下来让我们通过对axhal代码的一些修改来直观地展现一下输出的流程。

以qemu_virt_riscv平台为例， 我们首先关注

``` shell
modules/axhal/src/platform/qemu_virt_riscv/boot.rs 
```

这个文件， 其中的_start()函数被链接到".text.boot"段， 作为ArceOS运行的第一段代码。  具体的不同段的分配可以查看modules/axhal/linker.lds.S文件。

接下来我们尝试在里面直接调用ArceOS为我们封装好的sbi输出，

首先添加console_putchar函数方便输出我们想要输出的结果

```rust
unsafe fn console_putchar() {
  putchar(10); // 打印换行符
  putchar(72); // 打印"H“
  // 下面可以输出任何想要的内容， 只需更改参数即可
}
```

然后我们需要在代码中加入对console_putchar函数的调用， 我们需要在初始化页表之后， 初始化mmu之前执行console_putchar函数。 并且添加

```rust
console_putchar = sym console_putchar,
```

这一行， 以便汇编代码调用我们写的console_putchar函数

然后我们在初始化页表之后和初始化mmu之前调用输出

```rust
call {init_boot_page_table}
call {console_putchar}
call {init_mmu}
```

//  TODO!  完整的代码 (boot.rs) 见实验部分

此时我们只需执行

```shell
make ARCH=riscv64 A=apps/helloworld run
```

 如无意外， 我们在打印ArceOS的LOGO之前看到了我们之前调用sbi_call进行的输出"HELLO FROM SBI"， 当然，每个字符的输出只需要在console_putchar中自行添加即可。 

![image-20230706161125604](https://s2.loli.net/2023/07/06/OKws6HjEV478J5D.png)

至此，我们已经完成了从系统引导到输出的最小流程， 而且从代码来看，从开机到输出这个过程不依赖于任一组件，并且是可以在真实的硬件环境中(例如CV1811H的riscv开发板)进行输出的， 这也体现了Arceos的设计思路， 我们只需要复用这一个模块，就能很方便地对硬件进行操作了。 当然，Arceos中有更完整的封装好的console输出流程，上面只是一些直观简单的输出尝试，不过这一点简单的尝试已经可以展现出axhal组件强大的生命力了。

扩展阅读: 

  [axhal源代码]( https://github.com/rcore-os/arceos/tree/main/modules/axhal)