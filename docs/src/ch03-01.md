# 依靠axhal组件实现从系统引导到输出

## 初探axhal组件

ArceOS是一个组件化的操作系统 ，接下来三部分，我们将会对ArceOS的代码进行一点点修改，以体现组件间的密切联系和展示ArceOS启动的流程。

我们都知道，输出都是通过硬件完成的，正如你现在正在看的这份文档，它能显示在屏幕上都得益于我们的操作系统为我们封装好了硬件操作并能够执行它。但是我们的目标不正是写一个操作系统吗，所以很遗憾我们只能自己添加上与硬件相关的层的封装了，axhal应运而生。

```mermaid
graph TD
axhal
```

axhal组件提供了一层针对不同硬件平台的硬件封装，通过对axhal组件的调用，相当于我们直接可以对硬件进行操控，例如modules/axhal/src/platform/qemu_virt_riscv/console.rs里面提供了对字符输出的封装，我们可以直接调用这个函数进行字符的输出，接下来让我们通过对axhal代码的一些修改来直观地展现一下输出的流程。

## 动手尝试

以qemu_virt_riscv平台为例， 我们首先关注modules/axhal/src/platform/qemu_virt_riscv/boot.rs 这个文件， 其中的_start()函数被链接到".text.boot"段， 作为ArceOS运行的第一段代码。  具体的不同段的分配可以查看modules/axhal/linker.lds.S文件。

接下来我们尝试在里面直接调用ArceOS为我们封装好的sbi函数进行输出，首先添加console_putchar函数方便输出我们想要输出的结果。

```rust
unsafe fn console_putchar() {
  putchar(10); // 打印换行符
  putchar(72); // 打印"H“
  // 下面可以输出任何想要的内容， 只需更改参数即可
}
```

然后我们需要在代码中加入对console_putchar函数的调用， 我们需要在初始化页表之后， 初始化mmu之前执行console_putchar函数。 并且添加

```rust
console_putchar = sym console_putchar,
```

这一行， 以便汇编代码调用我们写的console_putchar函数

然后我们在初始化页表之后和初始化mmu之前调用输出: 

```rust
call {init_boot_page_table}
call {console_putchar}
call {init_mmu}
```

//  TODO!  完整的代码 (boot.rs) 见实验部分

此时我们只需执行: 

```shell
make ARCH=riscv64 A=apps/helloworld run
```

 如无意外， 我们在打印ArceOS的LOGO之前看到了我们调用putchar函数进行的输出"HELLO FROM SBI"， 当然，每个字符的输出只需要在console_putchar中自行添加即可。 

![image-20230706161125604](https://s2.loli.net/2023/07/06/OKws6HjEV478J5D.png)

## 总结

至此，我们已经完成了从系统引导到输出的最小流程， 而且从开机到输出这个过程不依赖于axhal外的任一组件，并且是可以在真实的硬件环境中(例如CV1811H的riscv开发板)进行输出的， 这也体现了Arceos的设计思路， 我们只需要复用这一个模块，就能很方便地对硬件进行操作了。 

让我们简单总结一下axhal组件的功能: 

- axhal: Hardware abstraction layer, provides unified APIs for cross-platform.

## 附录 

  [axhal源代码]( https://github.com/rcore-os/arceos/tree/main/modules/axhal)